;;;; dynamic binding

(import (rnrs base (6)))
(import (rnrs exceptions (6)))
(import (rnrs syntax-case (6)))
(import (rnrs mutable-pairs (6)))

(define (lookup id env)
  (if (pair? env)
      (if (eq? id (car (car env)))
          (cdr (car env))
          (lookup id (cdr env)))
      (raise "No such binding (lookup)")))

(define (update! id env value)
  (if (pair? env)
      (if (eq? (car (car env)) id)
          (begin (set-cdr! (car env) value)
                 value)
          (update! id (cdr env) value))
      (raise "No such binding (update!)")))

(define (extend env variables values)
  (cond ((pair? variables)
         (if (pair? values)
             (cons (cons (car variables) (car values))
                   (extend env (cdr variables) (cdr values)))
             (raise "Too less values")))
        ((null? variables)
          (if (null? values)
              env
              (raise "Too much values")))
         ((symbol? variables)
          (cons (cons variables values) env))))

(define (eprogn exps env)
  (if (pair? exps)
      (if (pair? (cdr exps))
          (begin (evaluate (car exps) env)
                 (eprogn (cdr exps) env))
          (evaluate (car exps) env))
      '()))

(define (evlis exps env)
  (if (pair? exps)
      (cons (evaluate (car exps) env)
            (evlis (cdr exps) env))
      '()))

;;; functions for dynamic binding

(define (d.invoke fn args env)
  (if (procedure? fn)
      (fn args env)
      (riase "Not a function")))

(define (d.make-function variables body env)
  (lambda (values current.env)
    (eprogn body (extend current.env variables values))))

(define (d.make-closure fun env)
  (lambda (values current.env)
    (fun values current.env)))

(define (d.evaluate exp env)
  (if (not (pair? exp))
      (cond ((symbol? exp) (lookup exp env))
            ((or (number? exp) (string? exp) (char? exp)
                 (boolean? exp) (vector? exp))
             exp)
            (else (raise "cannot evaluate")))
      (case (car exp)
        ((quote) (car (cdr exp)))
        ((if) (if (d.evaluate (car (cdr exp)) env)
                  (d.evaluate (car (cdr (cdr exp))) env)
                  (d.evaluate (car (cdr (cdr (cdr exp)))) env)))
        ((begin) (eprogn (cdr e) env))
        ((set!) (update! (car (cdr exp)) env (d.evaluate (car (cdr (cdr exp))) env)))
        ((function)
         (let* ((f (car (cdr e)))
                (fun (d.make-function (car (cdr f)) (cdr (cdr f)) env)))
           (d.make-closure fun env)))
        ((lambda) (d.make-function (car (cdr exp)) (cdr (cdr exp)) env))
        (else (d.invoke (d.evaluate (car exp) env)
                        (evlis (cdr exp) env)
                        env)))))
